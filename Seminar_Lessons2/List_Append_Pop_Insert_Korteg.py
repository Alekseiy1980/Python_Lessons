# # # # list_1 = []                 # объявили лист
# # # # print(list_1)
# # # # for i in range(5):
# # # #     list_1.append((i))      #заполнение списка
# # # #     print(list_1)           #вывод списка
# # #
# # #
# # # '''
# # #     удаление последнего элемента списка
# # #  '''
# # #
# # # # list_1 = [12, 6, -1, 21, 0]
# # # # print(list_1.pop())
# # # # print(list_1)
# # # # print(list_1.pop())
# # # # print(list_1)
# # # # print(list_1.pop())
# # # # print(list_1)
# # #
# # # '''
# # # Удаление конкретного элемента из списка
# # # '''
# # # # list_1 = [12, 6, -1, 21, 0]
# # # # print(list_1.pop(0))      # пишим в круглых скобках в методе pop  ккой элемент из списка нужно затереть
# # # # print(list_1)
# # #
# # # '''
# # # добавление элемента на нужную позицию
# # # '''
# # # # list_1 = [12, 6, -1, 21, 0]
# # # # print(list_1.insert(2, 11)) # первый аргумент это позиция, второй аргумент это значение
# # # # print(list_1)
# # #
# # # '''
# # # срезы
# # # '''
# # # list_1 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
# # # print(list_1[0])
# # # print(list_1[2])
# # # print(list_1[len(list_1) - 1])  # считает с конца листа
# # # print(list[-5])                 # считает с конца листа
# # # print(list_1[:])                # выведит весь список
# # # print(list_1)                   # выведит весь список
# # # print(list_1[:2])               # начинаем с начала списка и завершаем (N - 1) - элементом
# # # print(list_1[len(list_1)-2:])   # c какого элемента начать выводить список
# # # print(list_1[2:9])              # с кокого элемента начинаем и каким элементом завершаем вывод
# # # print(list_1[6:18])             # с кокого элемента начинаем и каким элементом завершаем вывод
# # # print(list_1[0:len(list_1):6])  # c начала до конца с определенным шагом
# # # print(list_1[::6])              # c начала до конца с определенным шагом
# #
# #
# # '''
# # Кортежи
# # Кортед - это неизменяемый список
# #
# # для чего они нужны, если их нельзя изменить?
# # В случае защиты каких-либо данных от изменений( намеренных или случайных)
# # Кортеж занимает меньше места в памяти и работает быстрее, по сравнению со списками
# # типо в них записывать пароли
# # '''
# # # t = ()          #создание пустого кортежа
# # # print(type(t))  #class <'typle'>
# # # t = (1.)
# # # print(type(t))
# # # t = (1)
# # # print(type(t))
# # # t = (28, 9, 1990,)  #кортеж
# # # print(type(t))
# # #
# # # v = [1, 5, 8]  #лист
# # # print(v)
# # # print(type(v))
# # #
# # # v = tuple(v)    # лист преобразование в кортеж
# # # print(v)
# # # print(type(v))
# # #
# # # a,b = 1,2       # множественное присваивание
# # # c = d = 1
# # #
# # # print(f' a = {a}, b = {b}, c = {c}, d = {d}')
# # # a, b, c = v     # распаковка кортежа
# # # print(f' a = {a}, b = {b}, c = {c}')
# # #
# # # '''
# # # Вывод кортежей
# # # '''
# # # t = (1, 2, 3, 4, 7,)
# # # print(t)
# # # for i in t:
# # #     print(i)
# # #
# # # print(t)
# # # for i in range(len(t)):     # так можно и со списками работать
# # #     print(t[i])
# #
# # '''
# # Словари - неупорядоченные коллекции произвольных обьектов с доупом по ключу
# # В списках в качестве ключа используется индекс элемента.
# # В словаре для определения элемента используется значения ключа(строка, число).
# # '''
# # dictionery = {}     # создали пустой словарь
# #
# # dictionery = {'up': 'w', 'left': 'a', 'down': 's', 'right': 'd'}
# # print(dictionery['left'])
# # print(dictionery['up'])
# # dictionery['left'] = '<='
# # print(dictionery['left'])
# # # print(dictionery['type'])
# # del dictionery['left']
# # for item in dictionery:     # вывод словаря
# #     print('{}: {}' .format(item, dictionery[item]))
# # dictionery[678] = 7654654       # добавили ключ и значение
# # for(k,v) in dictionery.items():     # вывод словаря
# #     print(k, v)
# # print(dictionery)
# # d = dict()          # создали пустой словарь
# # d['q'] = 'qwerty'   # записали в словарь
# # print(d)            # вывели словарь
# # d['w'] = 'werty'    # добавили ключ и значение
# # print(d)
# # print(d['q'])
# # print(dictionery.items()) # Вывод словаря, содержащий список элемент - картежей, и хронящий два значения( ключ и значения)
#
# '''
# Множества содержат в себе уникальные элементы, не обязательно упорядочные.
# Одно множество может содержать значения любых типов. Если у Вас два множества,
# Вы можете совершать над ними любые стандартные операции, например, обьединение,
# пересечение и разность.
# '''
#
# # colors = {'red', 'green', 'blue'} # создание множества
# # print(colors)
# # colors.add('red')       # добавиить элемент
# # print(colors)
# # colors.add('gray')      # добавиить элемент
# # print(colors)
# # colors.remove('red')       # удаление элемента
# # print(colors)
# # # colors.remove('red')        # выведит ошибку
# # colors.discard('red')           # сначало проверит если есть значение тогда удалит его, а если его нет то не поламает программу
# # print(colors)
# # colors.discard('green')           # сначало проверит если есть значение тогда удалит его, а если его нет то не поламает программу
# # print(colors)
# # colors.clear()                  # Удаляет все элементы с множества
# # print(colors)
# #
# # q = set()                   # сщздали новый список множества
#
# '''
# Операции со множествами
# '''
# # a = {1,2,3,5,8}
# # print(f'a = {a}')
# # b = {2,5,8,13,21}
# # print(f'b = {b}')
# # c = a.copy()                # копруем
# # print(f'c = {c}')
# # u = a.union(b)              # соединили множества
# # print(f'u = {u}')
# # i = a.intersection(b)       # пересечение (одинаковые значения множеств)
# # print(f'i = {i}')
# # d1 = a.difference(b)        # разность множеств
# # print(f'd1 = {d1}')
# # dr = b.difference(a)        # разность множеств
# # print(f'dr = {dr}')
# # q = a.union(b).difference(a.intersection(b)) # сначало ищем перессечение в А и B
# # print(f'q = {q}')
#
# '''
# замораживание множества
# '''
# a = {1,8,6}
# b = frozenset(a)        # нельзя будет изменять множество
# print(b)

'''
List Comprehension - у каждого языка программирования есть свои особенности и преимущества.
Одна из культовых фишек Python - list comprehension (редко переводится на русский,
но можно использовать определение (генератора списка). Comprehensioon легко читать, и
их используют как начинающие, так и опытные разработчики.
List comprehension - это упращенный подход к созданию списка, который задействует цикл
for, а также инструкции if - else для определения того, что в итоге окажется в
финальном списке

1. Простая ситуация - список

list_1 = [exp for item in interable]

2. Выборка по заданному условию

list_1 = [exp for item in iterable(if conditional)]
'''

# # задача создать список чисел от 1 до 100 (1 вариант)
#
# list_1 = []
# for i in range (1,101):
#     list_1.append(i)
# print(list_1)
#
# # таже задача только записана иначе
#
# list_2 = [i for i in range(101)]
# print(list_2)

# задача2 добавить условие(только четные числа)
list_1 = [i for i in range(1,101) if i % 2 == 0]
print(list_1)
# задача 3 вы решили создать пары каждому из чисел ( кортежи)
list_2 = [(i, i) for i in range(1, 101) if i % 2 == 0]
print(list_2)
# также можно умножать, делить, прибавлять, вычетать. Например умножить значение на 2
list_3 = [i * 2 for i in range(10) if i % 2 == 0]
print(list_3)